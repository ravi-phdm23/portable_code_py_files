"""
Settings Manager - Centralized configuration management.
Singleton pattern for application-wide settings.
"""

import json
import os
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, Optional


class SettingsManager:
    """
    Singleton settings manager for application-wide configuration.
    Manages app_settings.json and provides validated path access.
    """

    _instance: Optional['SettingsManager'] = None
    _settings: Optional[Dict[str, Any]] = None
    _settings_file = "app_settings.json"

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    @classmethod
    def get_instance(cls) -> 'SettingsManager':
        """Get singleton instance."""
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance

    def load_settings(self) -> Dict[str, Any]:
        """
        Load settings from file. Create with defaults if missing.
        Returns: Settings dictionary
        """
        if self._settings is not None:
            return self._settings

        settings_path = Path(self._settings_file)

        if settings_path.exists():
            try:
                with open(settings_path, 'r') as f:
                    self._settings = json.load(f)
            except Exception as e:
                print(f"Error loading settings: {e}, using defaults")
                self._settings = self._get_default_settings()
        else:
            print("Settings file not found, creating with defaults")
            self._settings = self._get_default_settings()
            self.save_settings(self._settings)

        # Ensure directories exist
        self._create_directories(self._settings['paths'])

        return self._settings

    def save_settings(self, settings: Dict[str, Any]) -> None:
        """
        Save settings to file.
        Args:
            settings: Settings dictionary to save
        """
        try:
            with open(self._settings_file, 'w') as f:
                json.dump(settings, f, indent=2)
            self._settings = settings
        except Exception as e:
            raise RuntimeError(f"Failed to save settings: {e}")

    def get_path(self, key: str) -> str:
        """
        Get individual path from settings.
        Args:
            key: Path key (database_path, images_dir, reports_dir, logs_dir, models_dir)
        Returns:
            Path string
        """
        settings = self.load_settings()
        return settings['paths'].get(key, '')

    def update_paths(self, paths: Dict[str, str]) -> Dict[str, Any]:
        """
        Update paths with validation and directory creation.
        Args:
            paths: Dictionary of paths to update
        Returns:
            Result dictionary with success status and errors
        """
        errors = self._validate_paths(paths)

        if errors:
            return {
                "success": False,
                "errors": errors,
                "message": "Path validation failed"
            }

        # Create directories
        try:
            self._create_directories(paths)
        except Exception as e:
            return {
                "success": False,
                "errors": {"general": f"Failed to create directories: {str(e)}"},
                "message": "Directory creation failed"
            }

        # Update settings
        settings = self.load_settings()
        settings['paths'].update(paths)
        settings['metadata']['last_modified'] = datetime.now().isoformat()
        settings['metadata']['modified_by'] = 'user'

        self.save_settings(settings)

        return {
            "success": True,
            "errors": {},
            "message": "Settings updated successfully"
        }

    def _validate_paths(self, paths: Dict[str, str]) -> Dict[str, str]:
        """
        Validate paths.
        Args:
            paths: Dictionary of paths to validate
        Returns:
            Dictionary of field -> error message
        """
        errors = {}

        # Validate database path
        if 'database_path' in paths:
            db_path = paths['database_path']
            if not db_path:
                errors['database_path'] = 'Database path cannot be empty'
            elif not db_path.startswith('sqlite:///'):
                errors['database_path'] = 'Database path must start with sqlite:///'
            else:
                # Check parent directory is writable
                try:
                    db_file = db_path.replace('sqlite:///', '')
                    db_dir = os.path.dirname(db_file) or '.'
                    if not os.path.exists(db_dir):
                        os.makedirs(db_dir, exist_ok=True)
                    if not os.access(db_dir, os.W_OK):
                        errors['database_path'] = f'Directory {db_dir} is not writable'
                except Exception as e:
                    errors['database_path'] = f'Invalid path: {str(e)}'

        # Validate directory paths
        for key in ['images_dir', 'reports_dir', 'logs_dir', 'models_dir']:
            if key in paths:
                path = paths[key]
                if not path:
                    errors[key] = 'Path cannot be empty'
                else:
                    # Check if path can be created
                    try:
                        test_path = Path(path)
                        # Don't actually create yet, just validate
                        if test_path.exists() and not os.access(path, os.W_OK):
                            errors[key] = f'Directory {path} is not writable'
                    except Exception as e:
                        errors[key] = f'Invalid path: {str(e)}'

        return errors

    def _create_directories(self, paths: Dict[str, str]) -> None:
        """
        Create directories if they don't exist.
        Args:
            paths: Dictionary of paths
        """
        for key in ['images_dir', 'reports_dir', 'logs_dir', 'models_dir']:
            if key in paths:
                path = paths[key]
                if path:
                    os.makedirs(path, exist_ok=True)

    def _get_default_settings(self) -> Dict[str, Any]:
        """
        Get default settings structure.
        Returns:
            Default settings dictionary
        """
        # Detect if running in Docker or locally
        is_docker = os.path.exists('/app') or os.getenv('DOCKER_ENV') == 'true'

        # Check for environment variables first (for Docker)
        if is_docker:
            # Docker-friendly paths that work with volume mounts
            database_path = os.getenv('DATABASE_PATH', 'sqlite:////app/data/uploaded_data.db')
            images_dir = os.getenv('IMAGES_DIR', '/app/data/images')
            reports_dir = os.getenv('REPORTS_DIR', '/app/data/reports')
            logs_dir = os.getenv('LOGS_DIR', '/app/data/logs')
            models_dir = os.getenv('MODELS_DIR', '/app/data/models')
        else:
            # Local development paths (relative to backend directory)
            database_path = os.getenv('DATABASE_PATH', 'sqlite:///./uploaded_data.db')
            images_dir = os.getenv('IMAGES_DIR', 'images')
            reports_dir = os.getenv('REPORTS_DIR', 'reports')
            logs_dir = os.getenv('LOGS_DIR', 'logs')
            models_dir = os.getenv('MODELS_DIR', 'models')

        return {
            "version": "1.0",
            "paths": {
                "database_path": database_path,
                "images_dir": images_dir,
                "reports_dir": reports_dir,
                "logs_dir": logs_dir,
                "models_dir": models_dir
            },
            "metadata": {
                "last_modified": datetime.now().isoformat(),
                "modified_by": "system"
            }
        }

    def reset_to_defaults(self) -> Dict[str, Any]:
        """
        Reset settings to defaults.
        Returns:
            Default settings dictionary
        """
        defaults = self._get_default_settings()
        self.save_settings(defaults)
        self._create_directories(defaults['paths'])
        return defaults

    def validate_single_path(self, path: str, path_type: str) -> Dict[str, Any]:
        """
        Validate a single path.
        Args:
            path: Path to validate
            path_type: Type of path ('database' or 'directory')
        Returns:
            Validation result with 'valid' and 'message' keys
        """
        if path_type == 'database':
            if not path.startswith('sqlite:///'):
                return {
                    "valid": False,
                    "message": "Database path must start with sqlite:///"
                }
            db_file = path.replace('sqlite:///', '')
            db_dir = os.path.dirname(db_file) or '.'
            if not os.path.exists(db_dir):
                try:
                    os.makedirs(db_dir, exist_ok=True)
                except Exception as e:
                    return {
                        "valid": False,
                        "message": f"Cannot create directory: {str(e)}"
                    }
            if not os.access(db_dir, os.W_OK):
                return {
                    "valid": False,
                    "message": f"Directory {db_dir} is not writable"
                }
            return {"valid": True, "message": "Valid database path"}

        elif path_type == 'directory':
            if not path:
                return {"valid": False, "message": "Path cannot be empty"}
            try:
                os.makedirs(path, exist_ok=True)
                if not os.access(path, os.W_OK):
                    return {
                        "valid": False,
                        "message": f"Directory {path} is not writable"
                    }
                return {"valid": True, "message": "Valid directory path"}
            except Exception as e:
                return {
                    "valid": False,
                    "message": f"Invalid path: {str(e)}"
                }

        return {"valid": False, "message": "Unknown path type"}
